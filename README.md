# Отчет по курсовой работе: Кастомный пул потоков (Custom Thread Pool Executor)

В рамках проекта разработан высоконагруженный пул потоков с расширенным функционалом управления задачами, балансировкой нагрузки и гибкой конфигурацией. Решение предлагает альтернативу стандартному ThreadPoolExecutor с поддержкой:

- Множественных очередей задач.
- Настраиваемых алгоритмов балансировки.
- Политик обработки перегрузок.
- Детального логирования событий.

## Основные возможности

### 1. Параметры пула
- **corePoolSize**: Базовое количество потоков.
- **maxPoolSize**: Максимальное количество потоков.
- **keepAliveTime**: Время простоя потока до завершения.
- **queueSize**: Максимальный размер очереди задач.
- **minSpareThreads**: Минимальное количество резервных потоков.

### 2. Алгоритмы балансировки
- **Round Robin**: Циклически перебирает очереди.
- **Least Loaded**: Выбирает очередь с наименьшим количеством задач.

### 3. Политики отказа
- **AbortPolicy**: Прерывание с исключением.
- **CallerRunsPolicy**: Выполнение задачи в потоке вызывающего.
- **DiscardPolicy**: Игнорирует задачу - не выполняется и не обрабатывается исключение.

### 4. Логирование
Подробное логирование всех ключевых событий:
- Создание и завершение потоков.
- Добавление задач в очередь.
- Выполнение задач.
- Обработка отказов.

## Производительность

### Сравнение с ThreadPoolExecutor
Условия тестирования:

- Нагрузка: до 1000 задач/сек.
- Параметры: оптимизированные под тип задач (CPU-bound/IO-bound).

Преимущества кастомного пула:
- Гибкое управление очередями.
- Балансировка нагрузки между несколькими очередями.

Недостатки:
- Накладные расходы на логику балансировки (~5-10% производительности).

### Оптимальные параметры
На основе тестирования рекомендуются следующие настройки:
| Параметр       | Значение для CPU-bound задач | Значение для IO-bound задач |
|----------------|-----------------------------|----------------------------|
| corePoolSize   | Число ядер CPU              | Число ядер CPU × 2         |
| maxPoolSize    | corePoolSize × 2            | corePoolSize × 4           |
| queueSize      | 100-500                     | 1000-2000                  |
| minSpareThreads| corePoolSize / 2            | corePoolSize               |

## Принцип работы механизма распределения задач

### Алгоритм работы:
1. **Поступление задачи**:
    - Задача распределяется в очередь с помощью выбранного балансировщика.
    - Если все очереди заполнены, создается новый поток (если не достигнут maxPoolSize).

2. **Обработка задач**:
    - Каждый рабочий поток (Worker) берет задачи из своей очереди.
    - При простое дольше keepAliveTime лишние потоки завершаются.

3. **Перегрузка**:
    - При достижении maxPoolSize и заполнении очередей применяется выбранная политика отказа.

## Демонстрация

Пример использования:

```java
CustomThreadFactory factory = new CustomThreadFactory("MyPool");
        CustomThreadPool pool = new CustomThreadPool(
                2,
                4,
                5,
                TimeUnit.SECONDS,
                100,
                1,
                factory,
                new AbortPolicy()
        );

        // Отправка задач
        for (int i = 0; i < 15; i++) {
            final int taskID = i;
            try {
                pool.execute(() -> {
                    System.out.println("Задача " + taskID + " Запущена в потоке " + Thread.currentThread().getName());
                    try {
                        Thread.sleep(2000);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                    System.out.println("Задача " + taskID + " завершена");
                });
                System.out.println("Задача " + taskID + " добавлена в очередь");
            } catch (Exception e) {
                System.out.println("Задача " + taskID + " отклонена. Причина: " + e.getMessage());
            }
        }

        Thread.sleep(10000);

        //Завершение пула
        pool.shutdown();
   ```

## Запуск проекта
1. Клонировать репозиторий
2. Собрать проект: mvn clean install
3. Логи будут записаны в logs/threadpool.log
4. Запустить демо: java -cp target/classes org.example.demo.Main


